# Huffman Encoder/Decoder (Java)

Проект реализует алгоритм кодирования и декодирования файлов по методу Хаффмана.  
Программа работает **из командной строки** и умеет кодировать и декодировать как текстовые, так и бинарные файлы.

## Сборка

Проект использует **Gradle**.

Сборка jar:

```bash
./gradlew build        # Linux / macOS
gradlew.bat build      # Windows
Готовый jar-файл появится в:

text
Копировать код
build/libs/huffman-1.0-SNAPSHOT.jar
(имя может немного отличаться, см. в папке build/libs).

Запуск
Общий формат:

bash
Копировать код
java -jar huffman-1.0-SNAPSHOT.jar encode <input> <output>
java -jar huffman-1.0-SNAPSHOT.jar decode <input> <output>
Параметры
encode — режим кодирования;

decode — режим декодирования;

<input> — путь к входному файлу (любой бинарный файл);

<output> — путь к выходному файлу.

Примеры
1. Кодирование текстового файла
bash
Копировать код
java -jar huffman-1.0-SNAPSHOT.jar encode test-data/test1.txt test-data/test1.huf
2. Декодирование обратно в текст
bash
Копировать код
java -jar huffman-1.0-SNAPSHOT.jar decode test-data/test1.huf test-data/test1_decoded.txt
3. Кодирование бинарного файла (Main.class)
bash
Копировать код
java -jar huffman-1.0-SNAPSHOT.jar encode build/classes/java/main/org/example/Main.class test-data/Main.huf
4. Декодирование бинарного файла
bash
Копировать код
java -jar huffman-1.0-SNAPSHOT.jar decode test-data/Main.huf test-data/Main_decoded.class
После этого Main.class и Main_decoded.class должны быть побайтно идентичны.

Формат закодированного файла (.huf)
Структура файла (все числа записываются в big-endian):

Заголовок

3 байта: ASCII-магия
H F M

1 байт: версия формата
1

Размер исходных данных

8 байт (long) — количество исходных байт до кодирования.

Словарь частот

4 байта (int) — m — количество различных символов.

Далее m записей:

1 байт — значение символа (0..255).

8 байт (long) — частота появления этого символа во входном файле.

Закодированные данные

Последовательность битов, полученная кодированием входных байт кодами Хаффмана.

Биты упакованы в байты, начиная со старших битов.
Последний байт может быть неполностью заполнен (дополнен нулями).
Точное количество декодируемых байт известно из поля «Размер исходных данных».

Реализация алгоритма
Алгоритм построения кодов Хаффмана реализован по учебному псевдокоду с процедурами:

Huffman(n) — основная рекурсивная процедура;

Up(n, q) — вставка суммы двух минимальных частот в отсортированный массив;

Down(n, j) — достройка кодов при разбиении комбинированного символа.

Основные классы:

org.example.Main — точка входа, разбор аргументов командной строки;

org.example.huffman.HuffmanCodec — кодирование/декодирование файлов;

org.example.huffman.HuffmanBuilder — построение кодов Хаффмана;

org.example.huffman.HuffmanTable — таблица кодов (символ → код);

org.example.huffman.BitOutputStream / BitInputStream — побитовая запись/чтение.

Тестовые примеры (по заданию)
Для проверки работы использовались:

test-data/test1.txt — текст из 10 одинаковых символов:
1111111111

test-data/test2.txt — текст длины 20 байт из 3 различных символов (частоты 10, 5, 5):
11111111112222233333

Бинарный файл build/classes/java/main/org/example/Main.class — результирующий .class файл самой программы.

Во всех трёх случаях декодированный файл побайтно совпадает с исходным.